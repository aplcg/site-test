<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lawton Communications Group</title>
  <!-- Tailwind CSS for UI utilities (non-critical) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- GSAP for smooth animation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <!-- Fonts + Custom Styles -->
  <link rel="stylesheet" href="style.css" />
</head>
<body class="h-screen w-screen overflow-hidden no-select has-custom-cursor">
  <!-- CUSTOM CURSOR ELEMENTS -->
  <div id="cursor-dot"></div>
  <div id="cursor-outline"></div>

  <!-- TOP GLASS NAVIGATION BAR -->
  <nav class="glass-nav">
    <div class="flex items-center">
      <a href="../index.html"><img src="../images/LCG logo.png" class="h-10 w-auto" alt="LCG logo" /></a>
    </div>
    <div class="flex gap-8 text-black font-medium">
      <a href="about/index.html" class="hover-trigger">About</a>
      <a href="Policies/index.html" class="hover-trigger">Policies</a>
      <a href="contact/index.html" class="hover-trigger">Contact</a>
    </div>
  </nav>

  <!-- 1. BACKGROUND LAYER -->
  <div id="layer-bg" class="parallax-layer grid-bg opacity-65 z-0"></div>

  <!-- 2. CONTENT LAYER (WORLD) -->
  <div id="layer-content" class="parallax-layer z-10">
    <!-- GENERATED GRIDS (script populates #grids) -->
    <div id="grids" class="grids z-20 pointer-events-auto"></div>
  </div>

  <div class="viewport-frame" aria-hidden="true"></div>

  <!-- UI Hint -->
  <div class="fixed bottom-8 left-1/2 -translate-x-1/2 text-black/30 text-xs uppercase tracking-widest pointer-events-none z-50 mix-blend-multiply">
    Move Cursor to Edges to Scroll
  </div>

  <!-- Controls: filters + zoom -->
  <div class="controls fixed bottom-4 left-1/2 -translate-x-1/2 z-50 flex items-center gap-6 px-4 py-2 bg-white/90 rounded-full shadow-md">
    <div class="filters flex gap-2">
      <button class="filter-btn active" data-filter="all">All</button>
      <button class="filter-btn" data-filter="Concio">Concio</button>
      <button class="filter-btn" data-filter="dragonfish">dragonfish</button>
      <button class="filter-btn" data-filter="Five by Five">Five by Five</button>
      <button class="filter-btn" data-filter="TSA">TSA</button>
    </div>
    <div class="zoom-control flex items-center gap-3">
      <button id="zoomMinus" class="text-black/60 hover:text-black">âˆ’</button>
      <div id="zoomValue" class="text-xs text-black/60">100%</div>
      <button id="zoomPlus" class="text-black/60 hover:text-black">+</button>
    </div>
  </div>

  <!-- SCRIPT: GSAP-driven panning + organic non-overlapping grid generation -->
  <script>
    (function () {
      const layerBg = document.getElementById('layer-bg');
      const layerContent = document.getElementById('layer-content');
      const gridsContainer = document.getElementById('grids');
      const cursorDot = document.getElementById('cursor-dot');
      const cursorOutline = document.getElementById('cursor-outline');

      // ========================= IMAGE SOURCES =========================
      // Replace with your real filenames under /images/
      const QUADRANT_IMAGES = [
        // Q1 Concio
        ['nokia.logo.avif','nestle.logo.jpg','image3.jpg','image4.jpg','image5.jpg','image6.jpg','image7.jpg','nokia.logo.avif','nestle.logo.jpg'],
        // Q2 dragonfish
        ['image10.jpg','image11.jpg','image12.jpg','image13.jpg','image14.jpg','image15.jpg','wcc.png','astraz.png','image18.jpg'],
        // Q3 Five by Five
        ['001-spot (1).avif','_bq.avif','001-FbF-Work-Arcane-1024x618.avif','001-spot.avif','_adidas.avif','image24.jpg','image25.jpg','image26.jpg','image27.jpg'],
        // Q4 TSA
        ['eon.next.png','jd.png','image30.jpg','DeLonghi-Logo.png','image32.jpg','image33.jpg','image34.jpg','image35.jpg','image36.jpg']
      ];
      const COMPANY_NAMES = ['Concio','dragonfish','Five by Five','TSA'];
      const QUADRANT_TAGS = ['Concio','dragonfish','Five by Five','TSA'];

      // Center logo as a card inside the world (moves with everything)
      const CENTER_LOGO = { file: 'LCG-Logo-Lockup-2025-SVG.svg', title: 'LCG', tag: 'LCG' };

      // ======================== CURSOR / PAN SETUP =====================
      let mouseX = innerWidth / 2,
        mouseY = innerHeight / 2;
      let outlineX = mouseX,
        outlineY = mouseY;
      let targetX = 0,
        targetY = 0,
        posX = 0,
        posY = 0;
      let ZOOM = 1.8;

      function getThreshold() { return Math.max(150, Math.floor(innerWidth * 0.22)); }

      addEventListener(
        'pointermove',
        (e) => {
          mouseX = e.clientX;
          mouseY = e.clientY;
          gsap.to(cursorDot, { x: mouseX, y: mouseY, duration: 0.1, overwrite: true });
        },
        { passive: true }
      );

      let PAN_LIMIT_X = Math.max(160, Math.floor(innerWidth * 0.8));
      let PAN_LIMIT_Y = Math.max(120, Math.floor(innerHeight * 0.8));
      function updatePanLimits() {
        PAN_LIMIT_X = Math.max(160, Math.floor(innerWidth * 0.8));
        PAN_LIMIT_Y = Math.max(120, Math.floor(innerHeight * 0.8));
      }

      // ================== UTILS: LOAD IMAGE ASPECT RATIOS ===============
      function preloadImages(sources) {
        const loaders = sources.map((s) =>
          new Promise((resolve) => {
            const im = new Image();
            im.onload = () => resolve({ ...s, w: im.naturalWidth || 12, h: im.naturalHeight || 12, ar: (im.naturalWidth || 12) / (im.naturalHeight || 12) });
            im.onerror = () => resolve({ ...s, w: 12, h: 12, ar: 12 });
            im.src = s.src;
          })
        );
        return Promise.all(loaders);
      }

      // ================== LAYOUT: ORGANIC, NO OVERLAP ===================
      // Rules:
      // - Each quadrant becomes a 3x3 grid (for 9 images). Cells include padding.
      // - Each image gets a target area and is sized to fit inside its cell using aspect ratio.
      // - Small jitter inside cell for organic feel (but never crosses cell bounds). 
      const CELL_GAP  = 30; // spacing between cells inside a quadrant
      const INNER_PAD = 12;  // inner padding inside each cell for the card
      const JITTER    = 8;   // max jitter in px inside each cell (both axes); set 0 for no jitter

      function buildLayout(meta) {
        gridsContainer.innerHTML = '';
        layerContent.querySelectorAll('.quadrant-watermark').forEach((w) => w.remove());

        const centerX = Math.floor(innerWidth / 2);
        const centerY = Math.floor(innerHeight / 2);
        const centerW = Math.max(300, Math.round(innerWidth * 0.22));
        const centerH = Math.max(240, Math.round(innerHeight * 0.20));
        const margin  = Math.max(12, Math.round(innerWidth * 0.02));

        const quads = [
          { x0: margin, x1: centerX - Math.floor(centerW / 2) - margin, y0: margin, y1: centerY - Math.floor(centerH / 2) - margin, label: COMPANY_NAMES[0] },
          { x0: centerX + Math.floor(centerW / 2) + margin, x1: innerWidth - margin, y0: margin, y1: centerY - Math.floor(centerH / 2) - margin, label: COMPANY_NAMES[1] },
          { x0: margin, x1: centerX - Math.floor(centerW / 2) - margin, y0: centerY + Math.floor(centerH / 2) + margin, y1: innerHeight - margin, label: COMPANY_NAMES[2] },
          { x0: centerX + Math.floor(centerW / 2) + margin, x1: innerWidth - margin, y0: centerY + Math.floor(centerH / 2) + margin, y1: innerHeight - margin, label: COMPANY_NAMES[3] }
        ];

        // Normalize min sizes
        quads.forEach((q) => {
          if (q.x1 <= q.x0 + 120) {
            const mid = Math.floor((q.x0 + q.x1) / 2);
            q.x0 = Math.max(margin, mid - 60);
            q.x1 = Math.min(innerWidth - margin, mid + 60);
          }
          if (q.y1 <= q.y0 + 100) {
            const mid = Math.floor((q.y0 + q.y1) / 2);
            q.y0 = Math.max(margin, mid - 50);
            q.y1 = Math.min(innerHeight - margin, mid + 50);
          }
        });

        // Build per quadrant (organic non-overlapping via cell layout + jitter)
        quads.forEach((q, qi) => {
          const qW = Math.max(160, q.x1 - q.x0);
          const qH = Math.max(140, q.y1 - q.y0);

          // Watermark
          const qCenterX = Math.floor((q.x0 + q.x1) / 2);
          const qCenterY = Math.floor((q.y0 + q.y1) / 2);
          const watermark = document.createElement('div');
          watermark.className = 'quadrant-watermark';
          watermark.textContent = q.label;
          watermark.style.left = Math.round((qCenterX / innerWidth) * 100) + '%';
          watermark.style.top  = Math.round((qCenterY / innerHeight) * 100) + '%';
          gridsContainer.appendChild(watermark);

          // Cell grid (3x3 for 9 images)
          const rows = 3, cols = 3;
          const totalGapX = (cols - 1) * CELL_GAP;
          const totalGapY = (rows - 1) * CELL_GAP;
          const cellW = (qW - totalGapX) / cols;
          const cellH = (qH - totalGapY) / rows;

          // Target area ~ 70% of cell to keep spacing nice
          const targetArea = (cellW - INNER_PAD * 2) * (cellH - INNER_PAD * 2) * 0.70;

          // Grab this quadrant's images (from meta, same order)
          const qItems = meta.filter((m) => m.quadrant === qi);

          qItems.forEach((m, i) => {
            const col = i % cols;
            const row = Math.floor(i / cols);

            // Base cell top-left
            const cellX = q.x0 + col * (cellW + CELL_GAP);
            const cellY = q.y0 + row * (cellH + CELL_GAP);

            // Compute card size from aspect ratio and target area
            const ar = Math.max(0.15, Math.min(6, m.ar || 1));
            let w = Math.sqrt(targetArea * ar);
            let h = w / ar;
            // Fit into cell bounds (minus inner padding)
            const maxW = Math.max(24, cellW - INNER_PAD * 2);
            const maxH = Math.max(24, cellH - INNER_PAD * 2);
            const scale = Math.min(maxW / w, maxH / h, 1);
            w *= scale; h *= scale;

            // Organic jitter inside cell but clamped
            const maxJx = Math.max(0, (cellW - INNER_PAD * 2 - w) / 2);
            const maxJy = Math.max(0, (cellH - INNER_PAD * 2 - h) / 2);
            const jx = (Math.random() * 2 - 1) * Math.min(JITTER, maxJx);
            const jy = (Math.random() * 2 - 1) * Math.min(JITTER, maxJy);

            const left = cellX + (cellW - w) / 2 + jx;
            const top  = cellY + (cellH - h) / 2 + jy;

            // Create card
            const art = document.createElement('article');
            art.className = 'previewCard uniform fixed';
            art.style.width = w + 'px';
            art.style.height = h + 'px';
            art.style.left = (left / innerWidth) * 100 + '%';
            art.style.top = (top / innerHeight) * 100 + '%';
            art.style.zIndex = 100 + qi * 10 + i;
            art.style.setProperty('--rot', ((Math.random() * 2 - 1) * 1.2).toFixed(2) + 'deg');
            art.dataset.tag = QUADRANT_TAGS[qi] || 'all';

            art.innerHTML = `
              <img class="backdrop w-full h-full object-cover" src="${m.src}" alt="" />
              <div class="content">
                <div class="category">${q.label}</div>
                <div class="title">${m.title || ''}</div>
              </div>`;

            gridsContainer.appendChild(art);
          });
        });

        // Center logo card (safe zone already reserved by quadrant split)
        const logo = document.createElement('article');
        logo.className = 'previewCard uniform fixed';
        const logoW = Math.min(520, Math.round(innerWidth * 0.26));
        const logoH = Math.round(logoW * 0.42);
        logo.style.width = logoW + 'px';
        logo.style.height = logoH + 'px';
        logo.style.left = (innerWidth / 2 - logoW / 2) / innerWidth * 100 + '%';
        logo.style.top = (innerHeight / 2 - logoH / 2) / innerHeight * 100 + '%';
        logo.style.zIndex = 999;
        logo.dataset.tag = CENTER_LOGO.tag;
        logo.innerHTML = `
          <img class="backdrop w-full h-full object-contain" src="images/${CENTER_LOGO.file}" alt="LCG Logo" />`;
        gridsContainer.appendChild(logo);

        // GSAP entrance animations
        const cards = gridsContainer.querySelectorAll('.previewCard');
        gsap.set(cards, { autoAlpha: 0, scale: 0.94, y: 8 });
        gsap.to(cards, {
          autoAlpha: 1,
          scale: 1,
          y: 0,
          duration: 0.6,
          ease: 'power2.out',
          stagger: { each: 0.04, from: 'random' }
        });
      }

      // ================== BUILD SOURCE META =============================
      function buildSources() {
        const sources = [];
        QUADRANT_IMAGES.forEach((arr, qi) => {
          arr.forEach((file, idx) => {
            sources.push({ src: `images/${file}`, tag: QUADRANT_TAGS[qi], label: COMPANY_NAMES[qi], quadrant: qi, order: idx });
          });
        });
        return sources;
      }

      // ================== PAN LOOP (GSAP) ===============================
      function computePush() {
        const t = getThreshold();
        let mx = 0,
          my = 0;
        if (mouseX < t) mx = Math.pow((t - mouseX) / t, 1.6);
        else if (mouseX > innerWidth - t) mx = -Math.pow((mouseX - (innerWidth - t)) / t, 1.6);
        if (mouseY < t) my = Math.pow((t - mouseY) / t, 1.6);
        else if (mouseY > innerHeight - t) my = -Math.pow((mouseY - (innerHeight - t)) / t, 1.6);
        return { mx, my };
      }
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      gsap.ticker.add(() => {
        const p = computePush();
        targetX += p.mx * 12;
        targetY += p.my * 12;
        targetX = clamp(targetX, -PAN_LIMIT_X, PAN_LIMIT_X);
        targetY = clamp(targetY, -PAN_LIMIT_Y, PAN_LIMIT_Y);
        posX += (targetX - posX) * 0.2;
        posY += (targetY - posY) * 0.2;

        layerContent.style.transform = `translate3d(calc(-50% + ${posX}px), calc(-50% + ${posY}px), 0) scale(${ZOOM})`;
        layerBg.style.transform = `translate3d(calc(-50% + ${posX * 0.42}px), calc(-50% + ${posY * 0.42}px), 0) scale(${1 + (ZOOM - 1) * 0.3})`;

        // Cursor outline smoothing
        outlineX += (mouseX - outlineX) * 0.12;
        outlineY += (mouseY - outlineY) * 0.12;
        cursorOutline.style.left = outlineX + 'px';
        cursorOutline.style.top  = outlineY + 'px';
      });

      // Touch pan
      let dragging = false, lx = 0, ly = 0;
      layerContent.addEventListener('pointerdown', (e) => { if (e.pointerType === 'touch') { dragging = true; lx = e.clientX; ly = e.clientY; } });
      addEventListener('pointermove', (e) => { if (dragging) { const dx = e.clientX - lx, dy = e.clientY - ly; lx = e.clientX; ly = e.clientY; targetX = clamp(targetX + dx, -PAN_LIMIT_X, PAN_LIMIT_X); targetY = clamp(targetY + dy, -PAN_LIMIT_Y, PAN_LIMIT_Y); } });
      addEventListener('pointerup', () => (dragging = false));

      // ================== FILTERS & ZOOM ================================
      const filterButtons = document.querySelectorAll('.filter-btn');
      function applyFilter(filter) {
        document.querySelectorAll('#grids .previewCard').forEach((c) => {
          if (filter === 'all' || c.dataset.tag === filter) c.classList.remove('hidden');
          else c.classList.add('hidden');
        });
      }
      window.applyFilter = applyFilter;
      filterButtons.forEach((btn) => {
        btn.addEventListener('click', () => {
          filterButtons.forEach((b) => b.classList.remove('active'));
          btn.classList.add('active');
          applyFilter(btn.dataset.filter);
        });
      });

      const zoomValue = document.getElementById('zoomValue');
      const zoomMinus = document.getElementById('zoomMinus');
      const zoomPlus = document.getElementById('zoomPlus');
      const ZOOM_MIN = 1, ZOOM_MAX = 1.9, ZOOM_STEP = 0.15;
      function updateZoomUI() { if (zoomValue) zoomValue.textContent = Math.round(ZOOM * 100) + '%'; }
      zoomMinus.addEventListener('click', () => { ZOOM = Number(Math.max(ZOOM_MIN, +(ZOOM - ZOOM_STEP)).toFixed(1)); updateZoomUI(); });
      zoomPlus.addEventListener('click', () => { ZOOM = Number(Math.min(ZOOM_MAX, +(ZOOM + ZOOM_STEP)).toFixed(1)); updateZoomUI(); });
      updateZoomUI();

      // ================== BUILD ================================
      function buildAll() {
        const sources = buildSources();
        preloadImages(sources).then((meta) => {
          buildLayout(meta);
        });
      }

      addEventListener('resize', () => { updatePanLimits(); buildAll(); });

      buildAll();
    })();
  </script>
</body>
</html>
