<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lawton Communications Group</title>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load Custom CSS -->
    <link rel="stylesheet" href="style.css">
</head>
<body class="h-screen w-screen overflow-hidden no-select has-custom-cursor">

    <!-- CUSTOM CURSOR ELEMENTS -->
    <div id="cursor-dot"></div>
    <div id="cursor-outline"></div>

    <!-- TOP GLASS NAVIGATION BAR -->
    <nav class="glass-nav">
    <div class="flex items-center">
        <img 
            src="images/LCG logo.png"
            class="h-10  w-auto"
        />
    </div>

    <div class="flex gap-8 text-black font-medium">
        <a href="about/index.html" class="hover-trigger">About</a>
        <a href="Policies/index.html" class="hover-trigger">Policies</a>
        <a href="contact/index.html" class="hover-trigger">Contact</a>
    </div>
</nav>


    <!-- PARALLAX LAYERS WRAPPER -->
    
    <!-- 1. BACKGROUND LAYER -->
    <div id="layer-bg" class="parallax-layer grid-bg opacity-50 z-0"></div>

    <!-- 2. CONTENT LAYER -->
    <div id="layer-content" class="parallax-layer z-10">
        
        <!-- HUB (center core) -->
<div class="fixed inset-9 flex items-center justify-center pointer-events-none z-[999]">
  <div class="hub-inner pointer-events-auto transition-transform duration-300 hover:scale-105">
    <img 
        src="images/LCG-Logo-Lockup-2025-SVG.svg"
        alt="LCG-Logo-Lockup-2025-SVG"
        class="max-w-[90vw] md:max-w-lg h-auto drop-shadow-2xl"
    />
  </div>
</div>


        <!-- SCATTERED IMAGES -->

        <!-- GENERATED GRIDS (script populates #grids) -->
        <div id="grids" class="grids z-20 pointer-events-auto"></div>

        <!-- Static scattered cards removed. All cards are now generated by the script into #grids -->
        <!-- If you prefer keeping any hand-placed examples, I can add a trimmed set back in. -->

    </div>

    <div class="viewport-frame" aria-hidden="true"></div>

    <!-- UI Hint -->
    <div class="fixed bottom-8 left-1/2 transform -translate-x-1/2 text-black/30 text-xs uppercase tracking-widest pointer-events-none z-50 mix-blend-multiply">
        Move Cursor to Edges to Scroll
    </div>

    <!-- Controls: filters + zoom -->
    <div class="controls fixed bottom-4 left-1/2 transform -translate-x-1/2 z-50 flex items-center gap-6 px-4 py-2 bg-white/90 rounded-full shadow-md">
      <div class="filters flex gap-2">
      <button class="filter-btn active" data-filter="all">All</button>
      <button class="filter-btn" data-filter="Quadrant 1">Quadrant 1</button>
      <button class="filter-btn" data-filter="Quadrant 2">Quadrant 2</button>
      <button class="filter-btn" data-filter="Quadrant 3">Quadrant 3</button>
      <button class="filter-btn" data-filter="Quadrant 4">Quadrant 4</button>
      </div>
      <div class="zoom-control flex items-center gap-3">
      <button id="zoomMinus" class="text-black/60 hover:text-black">−</button>
      <label for="zoomRange" class="zoom-label text-xs text-black/60">Zoom</label>
      <div id="zoomValue" class="text-xs text-black/60">100%</div>
      <button id="zoomPlus" class="text-black/60 hover:text-black">+</button>
      </div>
    </div>

  <!-- CLEANED SCRIPT: fixed grids, simple panning, cursor smoothing -->
  <script>
  (function(){
    const layerBg = document.getElementById('layer-bg');
    const layerContent = document.getElementById('layer-content');
    const gridsContainer = document.getElementById('grids');
    const cursorDot = document.getElementById('cursor-dot');
    const cursorOutline = document.getElementById('cursor-outline');

    let mouseX = window.innerWidth/2, mouseY = window.innerHeight/2;
    let outlineX = mouseX, outlineY = mouseY;
    let targetX = 0, targetY = 0, posX = 0, posY = 0;
    // UI zoom (1 = normal)
    let ZOOM = 1;

    function getThreshold(){ return Math.max(120, Math.floor(window.innerWidth * 0.18)); }

    document.addEventListener('pointermove', (e)=>{ mouseX = e.clientX; mouseY = e.clientY; cursorDot.style.left = mouseX + 'px'; cursorDot.style.top = mouseY + 'px'; }, {passive:true});

    // Default company names for each quadrant (customize as needed)
    const COMPANY_NAMES = ['Quadrant 1','Quadrant 2','Quadrant 3','Quadrant 4'];
    // quadrant tags mapped by quadrant index: Q1 -> Q4
    const QUADRANT_TAGS = ['Quadrant 1','Quadrant 2','Quadrant 3','Quadrant 4'];

    // pan limits (updated on resize)
    let PAN_LIMIT_X = Math.max(160, Math.floor(window.innerWidth * 0.28));
    let PAN_LIMIT_Y = Math.max(120, Math.floor(window.innerHeight * 0.24));
    function updatePanLimits(){ PAN_LIMIT_X = Math.max(160, Math.floor(window.innerWidth * 0.28)); PAN_LIMIT_Y = Math.max(120, Math.floor(window.innerHeight * 0.24)); }

    function generateGrids(){
      gridsContainer.innerHTML = '';
      layerContent.querySelectorAll('.quadrant-watermark').forEach(w=>w.remove());

      const centerX = Math.floor(window.innerWidth/2);
      const centerY = Math.floor(window.innerHeight/2);
      // central exclusion box (invisible)
      const centerW = Math.max(300, Math.round(window.innerWidth * 0.22));
      const centerH = Math.max(240, Math.round(window.innerHeight * 0.20));
      const margin = Math.max(12, Math.round(window.innerWidth * 0.02));

      // quadrant boxes (left/top / right/bottom) — available region for each quadrant
      const quads = [
        { x0: margin, x1: centerX - Math.floor(centerW/2) - margin, y0: margin, y1: centerY - Math.floor(centerH/2) - margin, label: COMPANY_NAMES[0] },
        { x0: centerX + Math.floor(centerW/2) + margin, x1: window.innerWidth - margin, y0: margin, y1: centerY - Math.floor(centerH/2) - margin, label: COMPANY_NAMES[1] },
        { x0: margin, x1: centerX - Math.floor(centerW/2) - margin, y0: centerY + Math.floor(centerH/2) + margin, y1: window.innerHeight - margin, label: COMPANY_NAMES[2] },
        { x0: centerX + Math.floor(centerW/2) + margin, x1: window.innerWidth - margin, y0: centerY + Math.floor(centerH/2) + margin, y1: window.innerHeight - margin, label: COMPANY_NAMES[3] }
      ];

      // normalize quad rects (ensure sane min sizes and clamps)
      quads.forEach(q => {
        if (q.x1 <= q.x0 + 120) {
          const mid = Math.floor((q.x0 + q.x1) / 2);
          q.x0 = Math.max(margin, mid - 60);
          q.x1 = Math.min(window.innerWidth - margin, mid + 60);
        }
        if (q.y1 <= q.y0 + 100) {
          const mid = Math.floor((q.y0 + q.y1) / 2);
          q.y0 = Math.max(margin, mid - 50);
          q.y1 = Math.min(window.innerHeight - margin, mid + 50);
        }
      });

      const aspects = [16/9, 4/3, 1]; // prefer landscape/square
      // Randomized placement per quadrant to emulate organic layout
      const ITEMS_PER_QUADRANT = 4; // fewer items so each can be larger
      const MIN_CARD_W_PX = 140;

      quads.forEach((q, qi)=>{
        const qWidth = Math.max(120, q.x1 - q.x0);
        const qHeight = Math.max(120, q.y1 - q.y0);

        // quadrant center (watermark)
        const qCenterX = Math.floor((q.x0 + q.x1) / 2);
        const qCenterY = Math.floor((q.y0 + q.y1) / 2);

        const watermark = document.createElement('div');
        watermark.className = 'quadrant-watermark';
        watermark.textContent = q.label;
        const leftPct = Math.max(2, Math.min(98, Math.round((qCenterX / window.innerWidth) * 100)));
        const topPct = Math.max(2, Math.min(98, Math.round((qCenterY / window.innerHeight) * 100)));
        watermark.style.left = leftPct + '%';
        watermark.style.top = topPct + '%';
        gridsContainer.appendChild(watermark);

        // place items randomly inside the quadrant, avoid heavy overlaps
        const placed = [];
        const rand = (a,b) => Math.floor(a + Math.random()*(b-a+1));

        for (let i=0;i<ITEMS_PER_QUADRANT;i++){
          // varied width relative to quadrant (larger, responsive sizes)
          const maxRatio = window.innerWidth < 640 ? 0.9 : 0.6;
          let w = Math.round(Math.max(MIN_CARD_W_PX, Math.min(Math.floor(qWidth * maxRatio), Math.round(qWidth*(0.18 + Math.random()*0.36)))));
          let aspect = aspects[Math.floor(Math.random()*aspects.length)];
          let h = Math.max(90, Math.round(w / aspect));

          // try to find a non-overlapping spot
          let tries = 0, cx=0, cy=0, rect;
          while(tries < 32){
            cx = rand(q.x0 + Math.floor(w/2), q.x1 - Math.floor(w/2));
            cy = rand(q.y0 + Math.floor(h/2), q.y1 - Math.floor(h/2));
            rect = { left: cx - Math.floor(w/2) - 20, top: cy - Math.floor(h/2) - 20, right: cx + Math.floor(w/2) + 20, bottom: cy + Math.floor(h/2) + 20 };
            const overlap = placed.some(p => !(rect.right < p.left || rect.left > p.right || rect.bottom < p.top || rect.top > p.bottom));
            if(!overlap) break;
            tries++;
            // on later tries, slightly reduce size to fit
            if(tries === 16){ w = Math.max(72, Math.round(w*0.75)); h = Math.max(56, Math.round(w / aspect)); }
          }
          placed.push(rect);

          const leftPct = (cx - w/2)/window.innerWidth * 100;
          const topPct = (cy - h/2)/window.innerHeight * 100;

          const art = document.createElement('article');
          art.className = 'previewCard uniform fixed';
          art.style.width = w + 'px';
          art.style.height = h + 'px';
          art.style.left = Math.max(2, Math.min(96, leftPct)) + '%';
          art.style.top = Math.max(2, Math.min(96, topPct)) + '%';
          art.style.zIndex = 100 + qi*10 + i;
          // subtle random rotation for organic feel (set as CSS variable so hover scale preserves it)
          const deg = (Math.random()*4 - 2).toFixed(2); // -2..2
          art.style.setProperty('--rot', deg + 'deg');

          const imgW = Math.max(400, Math.round(w*2));
          // assign tag based on quadrant (Q1..Q4)
          const tag = QUADRANT_TAGS[qi] || 'all';
          art.dataset.tag = tag;
          art.innerHTML = `\n              <img class="backdrop" src="https://picsum.photos/seed/q${qi}i${i}/${imgW}/${Math.max(120, Math.round(imgW * (h/w)))}" alt="">\n              <div class="content">\n                <div class="tag-pill">${tag}</div>\n                <div class="category">${q.label}</div>\n                <div class="title">Q${qi+1} #${i+1}</div>\n                <div class="description"><p>Client</p><span>›</span></div>\n              </div>`;

          gridsContainer.appendChild(art);
        }
      });
      // ensure current filter applied after grid generation
      const activeFilterBtn = document.querySelector('.filter-btn.active');
      if (typeof applyFilter === 'function' && activeFilterBtn) applyFilter(activeFilterBtn.dataset.filter);
    }

    // simple edge push calculation
    function computePush(){
      const t = getThreshold();
      let mx = 0, my = 0;
      if(mouseX < t) mx = Math.pow((t-mouseX)/t,1.6);
      else if(mouseX > window.innerWidth - t) mx = -Math.pow((mouseX - (window.innerWidth - t))/t,1.6);
      if(mouseY < t) my = Math.pow((t-mouseY)/t,1.6);
      else if(mouseY > window.innerHeight - t) my = -Math.pow((mouseY - (window.innerHeight - t))/t,1.6);
      return {mx,my};
    }

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function loop(){
      const p = computePush();
      // slightly more responsive: larger push and snappier lerp
      targetX += p.mx * 12; targetY += p.my * 12;

      // clamp targets so the world stops at the edges
      targetX = clamp(targetX, -PAN_LIMIT_X, PAN_LIMIT_X);
      targetY = clamp(targetY, -PAN_LIMIT_Y, PAN_LIMIT_Y);

      posX += (targetX - posX) * 0.20; posY += (targetY - posY) * 0.20;
      // include UI zoom
      layerContent.style.transform = `translate3d(calc(-50% + ${posX}px), calc(-50% + ${posY}px), 0) scale(${ZOOM})`;
      // stronger parallax for background; slightly different scale to preserve depth
      layerBg.style.transform = `translate3d(calc(-50% + ${posX*0.42}px), calc(-50% + ${posY*0.42}px), 0) scale(${1 + (ZOOM-1)*0.3})`;
      outlineX += (mouseX - outlineX) * 0.12; outlineY += (mouseY - outlineY) * 0.12; cursorOutline.style.left = outlineX + 'px'; cursorOutline.style.top = outlineY + 'px';
      requestAnimationFrame(loop);
    }

    // minimal touch drag to pan (clamped)
    let dragging=false, lx=0, ly=0;
    layerContent.addEventListener('pointerdown',(e)=>{ if(e.pointerType==='touch'){ dragging=true; lx=e.clientX; ly=e.clientY; } });
    window.addEventListener('pointermove',(e)=>{ if(dragging){ const dx=e.clientX-lx, dy=e.clientY-ly; lx=e.clientX; ly=e.clientY; targetX = clamp(targetX + dx, -PAN_LIMIT_X, PAN_LIMIT_X); targetY = clamp(targetY + dy, -PAN_LIMIT_Y, PAN_LIMIT_Y); }});
    window.addEventListener('pointerup',()=>dragging=false);

    window.addEventListener('resize', ()=>{ updatePanLimits(); setTimeout(()=>{ generateGrids(); }, 120); });

    // init: generate then check fit at normal zoom
    generateGrids();

    function ensureGridFits(){
      const cards = Array.from(document.querySelectorAll('#grids .previewCard'));
      if (!cards.length) return;
      const pad = 24;
      let minL = Infinity, minT = Infinity, maxR = -Infinity, maxB = -Infinity;
      cards.forEach(c=>{ const r = c.getBoundingClientRect(); minL = Math.min(minL, r.left); minT = Math.min(minT, r.top); maxR = Math.max(maxR, r.right); maxB = Math.max(maxB, r.bottom); });

      const vw = window.innerWidth; const vh = window.innerHeight;
      const centerX = vw/2, centerY = vh/2;
      const centerW = Math.max(260, Math.round(vw * 0.20));
      const centerH = Math.max(220, Math.round(vh * 0.18));
      const centerLeft = centerX - centerW/2, centerRight = centerX + centerW/2, centerTop = centerY - centerH/2, centerBottom = centerY + centerH/2;

      const overlapsCenter = cards.some(c=>{ const r = c.getBoundingClientRect(); return !(r.right < centerLeft || r.left > centerRight || r.bottom < centerTop || r.top > centerBottom); });
      const outOfBounds = (minL < pad || minT < pad || maxR > vw - pad || maxB > vh - pad);

      if (!overlapsCenter && !outOfBounds){ gridsContainer.style.transform = ''; gridsContainer.style.transformOrigin = ''; return; }

      const scaleX = (vw - pad*2) / (maxR - minL);
      const scaleY = (vh - pad*2) / (maxB - minT);
      let scale = Math.min(scaleX, scaleY, 1);
      // only apply a gentle scale-down when truly necessary
      if (scale < 0.98){ gridsContainer.style.transformOrigin = '50% 50%'; gridsContainer.style.transform = `scale(${scale})`; } else { gridsContainer.style.transform = ''; }
    }

    ensureGridFits();
    setTimeout(ensureGridFits, 300);
    // re-check when images finish loading
    document.querySelectorAll('#grids img').forEach(img=>{ if (!img.complete) img.addEventListener('load', ensureGridFits); });

    window.addEventListener('resize', ()=>{ updatePanLimits(); generateGrids(); ensureGridFits(); });

    requestAnimationFrame(loop);

    // Controls wiring: filters & zoom
    const filterButtons = document.querySelectorAll('.filter-btn');
    function applyFilter(filter){
      document.querySelectorAll('#grids .previewCard').forEach(c=> {
        if(filter === 'all' || c.dataset.tag === filter) { c.classList.remove('hidden'); } else { c.classList.add('hidden'); }
      });
    }
    filterButtons.forEach(btn=>{
      btn.addEventListener('click', ()=>{ filterButtons.forEach(b=>b.classList.remove('active')); btn.classList.add('active'); applyFilter(btn.dataset.filter); });
    });

    const zoomRange = document.getElementById('zoomRange');
    const zoomValue = document.getElementById('zoomValue');
    if (zoomRange) {
      // keep range in sync with programmatic changes
      zoomRange.step = zoomRange.step || '0.01';
      zoomRange.min = zoomRange.min || '0.75';
      zoomRange.max = zoomRange.max || '1.15';
      zoomRange.addEventListener('input', (e)=>{ ZOOM = parseFloat(e.target.value); zoomValue.textContent = Math.round(ZOOM*100)+'%'; });
    }

    // Zoom stepper buttons
    const zoomMinus = document.getElementById('zoomMinus');
    const zoomPlus = document.getElementById('zoomPlus');
    const ZOOM_MIN = 0.7, ZOOM_MAX = 1.5, ZOOM_STEP = 0.10
    function updateZoomUI(){
      if (zoomValue) zoomValue.textContent = Math.round(ZOOM*100)+'%';
      if (zoomRange) zoomRange.value = ZOOM;
    }
    if (zoomMinus) zoomMinus.addEventListener('click', ()=>{ ZOOM = Number(Math.max(ZOOM_MIN, +(ZOOM - ZOOM_STEP)).toFixed(2)); updateZoomUI(); });
    if (zoomPlus) zoomPlus.addEventListener('click', ()=>{ ZOOM = Number(Math.min(ZOOM_MAX, +(ZOOM + ZOOM_STEP)).toFixed(2)); updateZoomUI(); });
    // ensure initial display matches ZOOM
    updateZoomUI();

    document.body.classList.add('has-custom-cursor');
  })();
  </script>
  </body>
  </html>